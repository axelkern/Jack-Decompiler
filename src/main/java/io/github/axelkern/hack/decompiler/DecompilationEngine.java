package io.github.axelkern.hack.decompiler;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Decompiles VM files compiled with the official nand2tetris Jack compiler. VM
 * files generated by other compilers might work as well. Unsupported features
 * include register allocation, boolean shortcut evaluation, loop/jump
 * shortcuts.
 */
class DecompilationEngine {

    private enum FunctionKind {
        CONSTRUCTOR, FUNCTION, METHOD
    }

    private enum ArrayOrder {
        UNKNOWN, INDEX_LEFT, INDEX_RIGHT
    }

    private record Expression(String code, String type, Expression left, String op, Expression right) {
        Expression(String type, Expression left, String op, Expression right) {
            this("[]".equals(op) ? left.code + "[" + right.code + "]" // array
                    : "=".equals(op) ? left.code + " = " + right.code // assignment
                            : (left != null) // binary or unary?
                                    ? parenthesize(left.code) + OPERATORS.get(op) + parenthesize(right.code) // binary
                                    : OPERATORS.get(op) + parenthesize(right.code), // unary
                    type, left, op, right);
        }

        @Override
        public String toString() {
            return code;
        }
    }

    /**
     * Hierarchy of types with higher priority coming first (having the lowest
     * index). Only types with higher priority can override the type currently
     * stored in the symbol table. Unknown Class types will result in an index of
     * -1, thus having the highest priority.
     */
    private static final List<String> TYPE_HIERARCHY = List.of("String", "Array", "char", "$forced$int", "boolean",
            "int", "void");
    private static final Pattern LITERAL_START = Pattern.compile("String\\.new\\([0-9]+\\)\\.appendChar\\(");
    private static final Pattern NON_IDENT_CHARS = Pattern.compile("[^a-zA-Z0-9_\\.]"); // includes . for calls
    private static final Pattern IDENTIFIER = Pattern.compile("[A-Za-z_][A-Za-z_0-9]*");
    private static final List<String> REGS = List.of("temp0", "temp1", "temp2", "temp3", "temp4", "temp5", "temp6",
            "temp7", "pointer1");

    /* @formatter:off */
    private static final Map<String, String> OPERATORS = Map.ofEntries(
            Map.entry("add", " + "),
            Map.entry("sub", " - "),
            Map.entry("and", " & "),
            Map.entry("or", " | "),
            Map.entry("eq", " = "),
            Map.entry("lt", " < "),
            Map.entry("gt", " > "),
            Map.entry("not", "~"),
            Map.entry("neg", "-"),
            Map.entry("Math.multiply", " * "),
            Map.entry("Math.divide", " / "),
            Map.entry(",", ", ")); // for calls, currently not in use
    private static final Map<String, String> SEGMENT_TO_VARKIND = Map.of(
            "static", "static",
            "this", "field",
            "local", "local",
            "argument", "arg",
            "constant", "",
            "temp", "temp",
            "pointer", "pointer");
    /* @formatter:on */

    private String className;
    private String functionName;
    private List<String> vmCode;
    private int linePtr;
    private int functionPtr;
    private int nextLoopPtr;
    private Deque<Expression> stack;
    private Expression[] regs = new Expression[REGS.size()];
    private List<String> currentFunction;
    private List<String> jackCode;
    private SymbolTable symbols;
    private ArrayOrder arrayOrder;
    private boolean nonVoidReturn;
    private int indentLevel;

    public DecompilationEngine() {
        symbols = new SymbolTable();
        DeclarationReader.readDeclarations(symbols);
        stack = new ArrayDeque<>();
        arrayOrder = ArrayOrder.UNKNOWN;
    }

    /**
     * Analyzes the specified VM source code to detect data types. Calling this
     * method once or multiple times before decompiling, improves the quality of the
     * generated source code.
     * 
     * @param vmClassName The name of the VM class.
     * @param source      The VM code.
     */
    public void analyze(String vmClassName, List<String> source) {
        className = vmClassName;
        vmCode = source;
        decompileClass();
    }

    /**
     * Decompiles the specified VM source code and returns Jack source code. Calling
     * analyze once or multiple times before invoking this function will improve the
     * quality of the generated source code.
     * 
     * @param vmClassName The name of the VM class.
     * @param source      The VM code.
     * @return Returns the decompiled Jack source code.
     */
    public List<String> decompile(String vmClassName, List<String> source) {
        className = vmClassName;
        vmCode = source;
        return decompileClass();
    }

    private List<String> decompileClass() {
        jackCode = new ArrayList<>();
        linePtr = 0;
        indentLevel = 0;
        emitDoc(className);
        emit("class " + className + " {");
        emit("");
        updateType("this", className);
        int staticVars = detectVars(vmCode, "static");
        emitVars("static", "static", staticVars);
        int fieldVars = detectVars(vmCode, "this");
        emitVars("field", "field", fieldVars);
        emit("");
        decompileFunctions();
        emit("}");
        fixLiterals();
        cleanup();
        if (!Decompiler.keepVarNames) {
            renameVars(jackCode, "static", staticVars);
            renameVars(jackCode, "field", fieldVars);
        }
        return jackCode;
    }

    private void decompileFunctions() {
        while (linePtr < vmCode.size()) {
            decompileFunction();
        }
    }

    private void decompileFunction() {
        stack.clear();
        nextLoopPtr = -1;
        nonVoidReturn = false; // reset void detection
        functionPtr = linePtr;
        currentFunction = vmCode.subList(functionPtr, findCommand(vmCode, functionPtr + 1, "function ", false));
        int jackFunctionStart = jackCode.size(); // remember start of Jack source code start for renaming
        // decompile function header
        functionName = getSeg();
        int numLocals = getIdx();
        String localFunctionName = functionName.substring(functionName.indexOf('.') + 1);
        linePtr++; // consume function command
        FunctionKind kind = detectFunctionKind(); // consumes function header
        String returnType = getType("RETURN", "int"); // in case it is a constructor return type was set by detect
        // generate function declaration
        String decl = kind.name().toLowerCase() + " " + returnType + " " + localFunctionName + "(";
        int numArgs = detectVars(currentFunction, "argument");
        int argStart = 0;
        if (kind == FunctionKind.METHOD) {
            argStart = 1; // skip hidden argument in declaration
            updateType("arg0", className);
        }
        for (int i = argStart; i < numArgs; i++) {
            String varType = getType("arg" + i, "int");
            if (i > argStart) {
                decl = decl + ", ";
            }
            decl = decl + varType + " arg" + i;
        }
        decl = decl + ") {";
        emitDoc(functionName);
        emit(decl);
        // generate locals
        emitVars("var", "local", numLocals);
        // decompile body
        decompileStatements("$"); // dummy symbol
        emit("}");
        emit("");
        // adjust return type to void if function always returns 0
        if (!nonVoidReturn) {
            updateType("RETURN", "void");
        }
        if (!Decompiler.keepVarNames) {
            List<String> jackFunction = jackCode.subList(jackFunctionStart, jackCode.size());
            renameVars(jackFunction, "local", numLocals);
            renameVars(jackFunction, "arg", numArgs);
        }
    }

    /**
     * Detects whether a function is a constructor, a method or a static function by
     * checking the header commands at linePtr (if existent). The linePtr will be
     * advanced to the first command following the internal function header.
     * 
     * @return Returns the type of the function (method, constructor or function)
     */
    private FunctionKind detectFunctionKind() {
        FunctionKind type;
        if (getLine(linePtr).equals("push argument 0") && getLine(linePtr + 1).equals("pop pointer 0")) {
            type = FunctionKind.METHOD;
            linePtr += 2;
        } else if (getLine(linePtr).startsWith("push constant ") && getLine(linePtr + 1).equals("call Memory.alloc 1")
                && getLine(linePtr + 2).equals("pop pointer 0")) {
            type = FunctionKind.CONSTRUCTOR;
            linePtr += 3;
            // override manual field detection since constructor is a more reliable source
            updateType("FIELDS", Integer.toString(getIdx()));
            updateType("RETURN", className);
        } else {
            type = FunctionKind.FUNCTION;
        }
        updateType("TYPE", type.name());
        return type;
    }

    /**
     * Detects the number of variables in the specified segment (static, this,
     * local, argument).
     * 
     * @param code       List of VM source code lines (must only contain the current
     *                   function for local and arguments).
     * @param varSegment Specifies the segment (static, this, local, argument).
     * @return Returns the number of variables in the specified segment that were
     *         found.
     */
    private int detectVars(List<String> code, String varSegment) {
        String key = SEGMENT_TO_VARKIND.get(varSegment).toUpperCase() + "S";
        String value = getType(key);
        if (value != null) {
            return Integer.parseInt(value);
        }
        int numVars = code.stream().filter(s -> s.contains(" " + varSegment + " "))
                .map(s -> s.substring(s.lastIndexOf(' ') + 1)).mapToInt(n -> Integer.parseInt(n)).max().orElse(-1) + 1;
        updateType(key, Integer.toString(numVars));
        return numVars;
    }

    /**
     * Decompiles statements until the end of the function has been reached or a
     * blockEnd label has been reached. If blockEnd was detected, the label will not
     * be consumed, e.g. linePtr will still point to the blockEnd label in vmCode.
     * This is necessary if multiple nested blocks are using the same blockEnd
     * label.
     * 
     * @param blockEnd The VM label command that marks the end of the current block.
     */
    private void decompileStatements(String blockEnd) {
        while (linePtr < vmCode.size() && !getLine(linePtr).startsWith("function ")
                && !getLine(linePtr).equals(blockEnd)) {
            decompileStatement();
        }
    }

    private void decompileStatement() {
        do {
            String cmd = getCmd();
            switch (cmd) {
            case "label":
                if (nextLoopPtr < 0) { // not yet in a while loop (inside the current block)?
                    nextLoopPtr = detectLoop(); // check if this is the beginning of a while loop
                }
                linePtr++; // just ignore non-loop labels
                break;
            case "add":
            case "sub":
            case "and":
            case "or":
            case "eq":
            case "lt":
            case "gt":
            case "neg":
            case "not":
                decompileArithmetics(cmd);
                break;
            case "push":
                decompileVar();
                break;
            case "pop":
                decompileDoLet();
                break;
            case "if-goto":
                decompileIfWhile(); // boolean shortcuts can be captured here when stack level>1
                break;
            case "goto":
                linePtr++; // just ignore (block detection is based on labels)
                break;
            case "return":
                decompileReturn();
                break;
            case "call":
                decompileCall();
                break;
            default:
                System.err.println("Error: unexpected command in statement: " + cmd);
            }
        } while (!stack.isEmpty());
        return;
    }

    /**
     * Detects whether the label at position linePtr belongs to a loop.
     * 
     * @return Returns the line in vmCode where the loop ends (e.g. the final goto
     *         command) or -1 if the label does not belong to a loop.
     */
    private int detectLoop() {
        // Search for a goto statement inside the current function which jumps back to
        // the current label. If there is such statement, we have a loop. Since flow
        // optimizations might lead to multiple goto's to the same label, we search for
        // the last such goto statement.
        String searchPattern = "goto " + getSeg();
        int line = linePtr - functionPtr;
        int result;
        do {
            result = line;
            line = findCommand(currentFunction, line + 1, searchPattern, true);
        } while (line < currentFunction.size());
        result = result + functionPtr;
        if (result == linePtr) {
            return -1;
        } else {
            return result;
        }
    }

    private void decompileIfWhile() {
        int loopPtr = nextLoopPtr;
        nextLoopPtr = -1; // reset for embedded while/if
        String blockEndId;
        // check for inverted jump condition
        if (getCmd(linePtr + 1).equals("goto") && (loopPtr == -1 || (loopPtr - linePtr != 1))) {
            // The condition is not inverted when if-goto followed directly by a goto,
            // unless the goto belongs to an empty loop
            blockEndId = "label " + getSeg(linePtr + 1); // doesn't support loop shortcut
            linePtr += 3;
        } else { // condition needs to be inverted
            blockEndId = "label " + getSeg();
            if ("not".equals(stack.peek().op)) { // check if the expression is inverted too
                stack.push(stack.pop().right); // invert by skipping the preceding not
                linePtr++; // consume the IF-GOTO
            } else { // this can occur for example if a double negation was optimized away
                decompileArithmetics("not"); // invert by inserting a not (~)
                // IF-GOTO already "consumed" by arithmeticExpression (linePtr increased)
            }
        }
        emit((loopPtr == -1 ? "if" : "while") + " (" + stack.pop() + ") {");
        decompileStatements(blockEndId); // body
        // check for else block
        if (loopPtr == -1 && getCmd(linePtr - 1).equals("goto")) {
            emit("} else {");
            blockEndId = "label " + getSeg(linePtr - 1);
            linePtr++; // consume the label at the end of the if block
            decompileStatements(blockEndId); // else-body
        }
        emit("}");
    }

    private void decompileReturn() {
        Expression returnValue = stack.pop();
        if ("void".equals(getType("RETURN"))) {
            emit("return;");
        } else {
            if (!returnValue.code.equals("0")) {
                nonVoidReturn = true;
            }
            if ("boolean".equals(getType("RETURN")) && returnValue.code.equals("0")) {
                returnValue = new Expression("false", "boolean", null, null, null);
            }
            updateType("RETURN", returnValue.type);
            emit("return " + returnValue + ";");
        }
        linePtr++;
    }

    private void decompileDoLet() {
        String varName = getVar();
        if (stack.size() == 1 && !"pointer1".equals(varName)) { // do or let
            if (getLine(linePtr).equals("pop temp 0") && getCmd(linePtr - 1).equals("call")) { // do
                // It is just assumed that storing the return value in temp 0 indicates a "do"
                // call. It could also be checked if the function is void or unknown, but there
                // is also the possibility that the return value was purposely forfeited. To
                // definitely decide this, it would be necessary to check if there is a read
                // attempt on the return value (push temp 0).
                emit("do " + stack.pop() + ";");
                linePtr++;
            } else { // let
                Expression assignment = decompileAssignExpr(varName);
                if (varName != null && REGS.contains(varName)) { // TODO: Register allocation not yet supported
                    // Requires to keep track which registers have been set inside the function and
                    // create locals for it. (Technically global static would be more precise, but
                    // that doesn't allow the compiler to eliminate the variables away when
                    // recompiling.
                    regs[REGS.indexOf(varName)] = assignment.left;
                }
            }
        } else { // embedded or internal temporary assignment (don't emit code)
            if (varName.equals("pointer1")) {
                decodeArray();
            }
            regs[REGS.indexOf(varName)] = stack.pop();
            linePtr++;
        }
    }

    /**
     * Decompiles an assignment and returns the expression.
     * 
     * @param varName The name of the target variable.
     * @return Returns the assignment expression.
     */
    private Expression decompileAssignExpr(String varName) {
        Expression assignment;
        Expression valueExpr = stack.pop();
        String varType;
        Expression target;
        if (getLine(linePtr).startsWith("pop that")) { // array assignment
            varType = valueExpr.type; // target is of type Array<?>, so the value type is used
            target = regs[REGS.indexOf("pointer1")];
            int index = getIdx();
            if (index != 0) { // not required for standard compiler
                // TODO: Currently assuming that an index other than 0 is linked to a constant
                // array access at [index]. It doesn't have to be like that (i.e.
                // x=a[x]+a[x+10]). Replacement is only safe if rightExpr is 0. Otherwise it
                // should be added.
                target = new Expression(target.type, target.left, target.op,
                        new Expression(Integer.toString(index), "int", null, null, null));
            }
        } else { // simple assignment
            updateType(varName, valueExpr.type);
            varType = getType(varName);
            target = new Expression(varName, varType, null, null, null);
            if ("boolean".equals(varType) && valueExpr.code.equals("0")) {
                valueExpr = new Expression("false", "boolean", null, null, null);
            }
        }
        // add parenthesis when assigning a comparison or boolean
        // (required by standard compiler)
        if ("eq".equals(valueExpr.op) || "lt".equals(valueExpr.op) || "gt".equals(valueExpr.op)
                || "false".equals(valueExpr.code) || "true".equals(valueExpr.code)) {
            valueExpr = new Expression("(" + valueExpr.code + ")", valueExpr.type, valueExpr.left, valueExpr.op,
                    valueExpr.right);
        }
        assignment = new Expression(varType, target, "=", valueExpr);
        linePtr++;
        emit("let " + assignment + ";");
        return assignment;
    }

    /**
     * Decompiles a variable or a constant and pushes it to the stack.
     */
    private void decompileVar() {
        String varName = getVar();
        Expression varExpr;
        String seg = getSeg();
        switch (seg) {
        case "that":
            varExpr = regs[REGS.indexOf("pointer1")];
            int index = getIdx();
            if (index != 0) { // not required for standard compiler
                // TODO: Currently assuming that an index other than 0 is linked to a constant
                // array access at [index]. It doesn't have to be like that (i.e.
                // x=a[x]+a[x+10]). Replacement is only safe if rightExpr is 0. Otherwise it
                // should be added.
                varExpr = new Expression(varExpr.type, varExpr.left, varExpr.op,
                        new Expression(Integer.toString(index), "int", null, null, null));
            }
            break;
        case "temp":
            varExpr = regs[REGS.indexOf(varName)];
            break;
        default:
            String exprType;
            if (isConstant(varName)) {
                if (varName.equals("0")) {
                    exprType = null;
                } else {
                    exprType = "int";
                }
            } else {
                exprType = getType(varName);
            }
            varExpr = new Expression(varName, exprType, null, null, null);
        }
        linePtr++;
        stack.push(varExpr);
    }

    private void decompileCall() {
        String calledFunction = getSeg();
        if (calledFunction.equals("Math.multiply") || calledFunction.equals("Math.divide")) {
            decompileArithmetics(calledFunction);
        } else {
            int numArgs = getIdx();
            String decl = "";
            int argStart = 0;
            if (symbols.find(calledFunction, "TYPE").equals("METHOD")) {
                argStart = 1;
            }
            for (int i = numArgs - 1; i >= argStart; i--) {
                Expression arg = stack.pop();
                if ("boolean".equals(symbols.get(calledFunction, "arg" + i)) && arg.code.equals("0")) {
                    arg = new Expression("false", "boolean", null, null, null);
                }
                if (i < numArgs - 1) {
                    decl = ", " + decl;
                }
                decl = arg + decl;
                updateType(arg, symbols.get(calledFunction, "arg" + i));
                if (arg.type != null) { // reverse type update towards called function
                    int typeLevel = TYPE_HIERARCHY.indexOf(arg.type);
                    if (typeLevel >= TYPE_HIERARCHY.indexOf("Array") // avoid overriding casted args with class types
                            && typeLevel < TYPE_HIERARCHY.indexOf("int")) { // no need to update int (default)
                        symbols.add(calledFunction, "arg" + i, arg.type);
                    }
                }
            }
            String exprType = symbols.get(calledFunction, "RETURN");
            if (argStart == 1) { // method
                Expression calledObject = stack.pop();
                String calledClass = calledFunction.substring(0, calledFunction.indexOf('.'));
                calledFunction = calledFunction.substring(calledFunction.indexOf('.') + 1);
                if (!calledObject.code.equals("this")) { // method in other class
                    calledFunction = calledObject + "." + calledFunction;
                    updateType(calledObject, calledClass);
                }
            }
            // just push the call, omitting the argument expression trees (no use for it)
            stack.push(new Expression(calledFunction + "(" + decl + ")", exprType, null, null, null));
            linePtr++;
        }
    }

    private void decompileArithmetics(String op) {
        Expression rightExpr = stack.pop();
        switch (op) {
        case "neg":
            stack.push(new Expression("int", null, op, rightExpr));
            break;
        case "not":
            if (rightExpr.code.equals("0")) {
                stack.push(new Expression("true", "boolean", null, "not", rightExpr));
            } else {
                stack.push(new Expression(rightExpr.type, null, op, rightExpr));
            }
            break;
        default: // binary
            Expression leftExpr = stack.pop();
            String exprType = resolveType(leftExpr, op, rightExpr);
            stack.push(new Expression(exprType, leftExpr, op, rightExpr));
            break;
        }
        linePtr++;
    }

    /**
     * Attempts to derive the data type of a binary expression.
     * 
     * @param left  Left expression.
     * @param op    Binary operator.
     * @param right Right expression.
     * @return Returns the data type or null if the type cannot be derived.
     */
    private String resolveType(Expression left, String op, Expression right) {
        switch (op) {
        case "add":
        case "sub":
        case "Math.multiply":
        case "Math.divide":
            updateType(left, "int");
            updateType(right, "int");
            return "int";
        case "and": // this can be logical or bitwise
        case "or": // therefore conservative update of type
            if (left.type != null && left.type.equals(right.type)) {
                return left.type;
            }
            if (op.equals("and") && ("boolean".equals(left.type) || "boolean".equals(right.type))) {
                return "boolean";
            }
            return null;
        case "lt":
        case "gt":
            updateType(left, "$forced$int"); // force int for operand
            updateType(right, "$forced$int"); // force int for operand
            return "boolean";
        case "eq": // one side with type int should imply that both are int
            if (Decompiler.forceChar) {
                if ("char".equals(left.type)) {
                    updateType(right, "char");
                } else if ("char".equals(right.type)) {
                    updateType(left, "char");
                }
            }
            if ("int".equals(left.type)) {
                updateType(right, "int");
            } else if ("int".equals(right.type)) {
                updateType(left, "int");
            }
            return "boolean";
        default:
            return null; // will never be reached
        }
    }

    /**
     * Converts an expression which is to be written to pointer 1 into an Array
     * expression.
     * 
     * @return Returns the Array variable as Jack source code.
     */
    private void decodeArray() {
        Expression array = stack.pop();
        if ("add".equals(array.op)) {
            if (arrayOrder == ArrayOrder.UNKNOWN) { // try to derive stack order of array
                if (isConstant(array.left.code) || !IDENTIFIER.matcher(array.left.code).matches()
                        || (!"Array".equals(getType(array.left.code)) && "Array".equals(getType(array.right.code)))) {
                    arrayOrder = ArrayOrder.INDEX_LEFT;
                }
                if (isConstant(array.right.code) || !IDENTIFIER.matcher(array.right.code).matches()
                        || (!"Array".equals(getType(array.right.code)) && "Array".equals(getType(array.left.code)))) {
                    arrayOrder = ArrayOrder.INDEX_RIGHT;
                }
            }
            if (arrayOrder == ArrayOrder.INDEX_RIGHT) {
                array = new Expression(null, array.left, "[]", array.right);
            } else { // also default for UNKNOWN
                array = new Expression(null, array.right, "[]", array.left);
            }
            updateType(array.right, "int");
        } else { // no index, just constant offset (not required for standard compiler)
            array = new Expression(null, array, "[]", new Expression("0", "int", null, null, null));
        }
        updateType(array.left, "Array");
        stack.push(array);
    }

    /**
     * Searches for the specified pattern inside the code.
     * 
     * @param code    List to search in.
     * @param startAt The line number in vmCode where the search is starting.
     * @param pattern The pattern to search for.
     * @param exact   Specifies if the line has to match exactly the pattern.
     * @return Returns the line number in vmCode which matches (if exact==true) or
     *         starts with (if exact==false) the specified pattern or vmCode.size()
     *         if no such pattern can be found.
     */
    private int findCommand(List<String> code, int startAt, String pattern, boolean exact) {
        int line;
        for (line = startAt; line < code.size(); line++) {
            if (code.get(line).startsWith(pattern) && (!exact || code.get(line).length() == pattern.length())) {
                break;
            }
        }
        return line;
    }

    private String getType(String identifier, String defaultType) {
        String type = getType(identifier);
        if (type == null) {
            return defaultType;
        } else {
            return type.replaceAll("\\$forced\\$", ""); // remove forced tag
        }
    }

    private String getType(String identifier) {
        return symbols.get(className, functionName, identifier);
    }

    private void updateType(String identifier, String type) {
        if (type != null) {
            if (IDENTIFIER.matcher(identifier).matches()) { // is it an identifier?
                String currentType = symbols.get(className, functionName, identifier);
                if (currentType == null || TYPE_HIERARCHY.indexOf(type) < TYPE_HIERARCHY.indexOf(currentType)
                        || (Decompiler.charAsInt && type.equals("char"))) {
                    if (Decompiler.charAsInt && type.equals("char")) {
                        type = "int";
                    }
                    symbols.add(className, functionName, identifier, type);
                }
            }
        }
    }

    private void updateType(Expression expr, String type) {
        updateType(expr.code, type);
    }

    private static boolean isConstant(String s) {
        return Character.isDigit(s.charAt(0)) || s.equals("true") || s.equals("false") || s.equals("null");
    }

    private void emit(String cmd) {
        if (cmd.contains("}")) {
            indentLevel--;
        }
        if (cmd.length() > 0) {
            for (int i = 0; i < indentLevel; i++) {
                cmd = "    " + cmd;
            }
        }
        jackCode.add(cmd);
//        System.out.println(cmd);
        if (cmd.contains("{")) {
            indentLevel++;
        }
    }

    private void emitVars(String id, String varKind, int numVars) {
        for (int i = 0; i < numVars; i++) {
            emitDoc(varKind + i);
            emit(id + " " + getType(varKind + i, "int") + " " + varKind + i + ";");
        }
    }

    private void emitDoc(String key) {
        String doc = symbols.get(className, key + "$DOC");
        if (doc != null) {
            emit(doc);
        }
    }

    private static String parenthesize(String expr) {
        // search for outer brackets/parenthesis
        int parenStart = expr.indexOf('(');
        int bracketStart = expr.indexOf('[');
        char openChar;
        char closeChar;
        int openIndex;
        if (bracketStart < 0 || (parenStart >= 0 && parenStart <= bracketStart)) {
            openChar = '(';
            closeChar = ')';
            openIndex = parenStart;
        } else {
            openChar = '[';
            closeChar = ']';
            openIndex = bracketStart;
        }
        String outsideBrackets;
        if (openIndex >= 0) { // found brackets/parenthesis
            // search for corresponding closing bracket
            int level = 1;
            int closeIndex;
            for (closeIndex = openIndex + 1; closeIndex < expr.length(); closeIndex++) {
                if (expr.charAt(closeIndex) == openChar) {
                    level++;
                } else if (expr.charAt(closeIndex) == closeChar) {
                    level--;
                    if (level == 0) {
                        break;
                    }
                }
            }
            // check only characters outside the outer brackets
            outsideBrackets = expr.substring(0, openIndex) + expr.substring(closeIndex + 1);
        } else {
            outsideBrackets = expr;
        }
        if (NON_IDENT_CHARS.matcher(outsideBrackets).find()) {
            return "(" + expr + ")";
        } else {
            return expr;
        }
    }

    private void cleanup() {
        for (int i = 1; i < jackCode.size(); i++) {
            if (jackCode.get(i - 1).length() == 0 && jackCode.get(i).length() == 0) {
                jackCode.remove(i - 1);
                i--;
            }
        }
    }

    private void fixLiterals() {
        for (int i = 0; i < jackCode.size(); i++) {
            String tail = jackCode.get(i);
            Matcher matcher = LITERAL_START.matcher(tail);
            if (matcher.find()) {
                int pos = matcher.start();
                String head = tail.substring(0, pos);
                tail = tail.substring(pos + 11);
                int strLength = Integer.parseInt(tail.substring(0, tail.indexOf(')')));
                StringBuilder stringLiteral = new StringBuilder("\"");
                for (int j = 0; j < strLength; j++) {
                    tail = tail.substring(tail.indexOf('(') + 1);
                    stringLiteral.append((char) Integer.parseInt(tail.substring(0, tail.indexOf(')'))));
                }
                stringLiteral.append('"');
                jackCode.set(i, head + stringLiteral + tail.substring(tail.indexOf(')') + 1));
                i--;
            }
        }
    }

    private String getLine(int line) {
        return vmCode.get(line).trim().replaceAll("[ ]+", " ").split("//")[0].trim();
    }

    private String getCmd() {
        return getCmd(linePtr);
    }

    private String getCmd(int line) {
        return getLine(line).split(" ")[0];
    }

    private int getIdx() {
        return getIdx(linePtr);
    }

    private int getIdx(int line) {
        try {
            return Integer.parseInt(getLine(line).split(" ")[2]);
        } catch (Exception e) {
            return 0;
        }
    }

    private String getSeg() {
        return getSeg(linePtr);
    }

    private String getSeg(int line) {
        try {
            return getLine(line).split(" ")[1];
        } catch (Exception e) {
            return "";
        }
    }

    private String getVar() {
        String seg = getSeg();
        int index = getIdx();
        if (seg.equals("pointer") && index == 0) {
            return "this";
        } else {
            String varKind = SEGMENT_TO_VARKIND.get(seg);
            if (varKind == null) {
                return null;
            } else {
                return varKind + index;
            }
        }
    }

    private void renameVars(List<String> code, String varKind, int varCount) {
        for (int i = varCount - 1; i >= 0; i--) {
            String varName = symbols.get(className, functionName, varKind + i + "$NAME");
            if (varName != null) {
                replaceInList(code, varKind + i, varName);
            } else {
                String varType = symbols.get(className, functionName, varKind + i);
                // replace Class types except Array (should be obvious due to the [] operator)
                if (varType != null && TYPE_HIERARCHY.indexOf(varType) < TYPE_HIERARCHY.indexOf("Array")) {
                    varType = Character.toLowerCase(varType.charAt(0)) + varType.substring(1);
                    // TODO: this may also falsely alter literals that coincidentally contain the
                    // variable name (though unlikely)
                    replaceInList(code, varKind + i, varType + "_" + varKind + i);
                }
            }
        }
    }

    private static void replaceInList(List<String> list, String search, String replace) {
        for (int i = 0; i < list.size(); i++) {
            list.set(i, list.get(i).replaceAll(search, replace));
        }
    }
}
